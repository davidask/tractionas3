/** * @version 1.0 * @author David Dahlstroem | daviddahlstroem.com *  *  * Copyright (c) 2009 David Dahlstroem | daviddahlstroem.com *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * */package org.tractionas3.media{	import org.tractionas3.core.interfaces.ICloneable;	import org.tractionas3.core.interfaces.ICoreInterface;	import org.tractionas3.events.SoundPlaybackEvent;	import org.tractionas3.events.WeakEventDispatcher;	import org.tractionas3.media.IMediaPlayback;	import flash.events.Event;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	/**	 * SoundPlayback class provides a base API for playing and controlling sound playback.	 */	public class SoundPlayback extends WeakEventDispatcher implements ICoreInterface, IMediaPlayback, ICloneable	{		/** @private */		protected var _sound:Sound;		private var _soundChannelReference:SoundChannel;		private var _soundTransform:SoundTransform;		private var _position:Number;		private var _playing:Boolean;		private var _loopRuns:uint = 0;		public var loops:uint;				/**		 * Creates a new SoundPlayback object.		 * 		 * @param sound Reference to a sound object.		 */		public function SoundPlayback(sound:Sound = null)		{			super(this);						_playing = false;						if(sound) setSound(sound);		}		/**		 * Starts or resumes sound playback.		 */		public function play():void		{			if(playing) return;						_soundChannel = _sound.play(_position, 0, _soundTransform);						_playing = true;		}		/**		 * Starts sound playback at a defined position.		 * 		 * @param position Playback starting position.		 */		public function playAt(position:Number):void		{			if(playing) _soundChannel.stop();						_position = position;						_soundChannel = _sound.play(_position, 0, _soundTransform);						_playing = true;		}		/**		 * Pauses sound playback.		 */		public function pause():void		{			_position = _soundChannel.position;						_soundChannel.stop();						_playing = false;		}		/**		 * Stops sound playback.		 * The position is set to zero.		 */		public function stop():void		{			seek(0);						_loopRuns = 0;						_soundChannel.stop();						_playing = false;		}		/**		 * Sets the position of the sound playback.		 */		public function seek(position:Number):void		{			if(playing) _soundChannel.stop();						_position = position;						_soundChannel = _sound.play(_position, 0, _soundTransform);						if(!playing) pause(); 		}		/**		 * Sets the volume of the sound playback.		 */		public function get volume():Number		{			return _soundTransform.volume;		}		public function set volume(value:Number):void		{			_soundTransform.volume = value;						_soundChannel.soundTransform = _soundTransform;		}		/**		 * Indicates the number of loops left.		 */		public function get remainingLoops():uint		{			return Math.max(loops - _loopRuns, 0);		}		/**		 * Changes the sound of the SoundPlayback. If the Soundplayback is currently playing, the new sound will begin playing automatically.		 * Use <code>SoundPlayback.stop()</code> <code>SoundPlayback.pause()</code> before calling this method if you wish to ensure that the new sound is not playing.		 * 		 * @param sound Reference to new Sound.		 * @param resetPosition If <code>true</code> the new sound will begin playing from start.		 * If set to <code>false</code> the new sound will attempt to play at the same position as the old sound.		 */		 		/* 		 * TODO Test setSound() method of SoundPlayback class.		 */		public function setSound(sound:Sound, resetPosition:Boolean = true):void		{			_sound = sound;						_soundTransform = new SoundTransform();						var soundPos:Number = (resetPosition) ? 0 : position;						if(_soundChannel) _soundChannel.stop();						seek(Math.min(soundPos, length));		}		/**		 * Returns the length of the sound in milliseconds.		 * If the sound is not completely loaded the sound length will be estimated.		 */		public function get length():Number		{			if(_sound.bytesLoaded == _sound.bytesTotal) return _sound.length;						return (_sound.bytesTotal / (_sound.bytesLoaded / _sound.length));		}		/**		 * Sets the pan of the sound playback.		 * Negative values set pan to left channel, while positive values sets pan to right channel.		 */		public function get pan():Number		{			return _soundTransform.pan;		}		public function set pan(value:Number):void		{			if(value < -1) value = -1;						if(value > 1) value = 1;						_soundTransform.pan = value;						_soundChannel.soundTransform = _soundTransform;		}		/**		 * Returns the position of the sound playback.		 */		public function get position():Number		{			if(!_soundChannel) return 0;						return _soundChannel.position;		}		/**		 * Indicates whether the sound is currently playing.		 */		public function get playing():Boolean		{			return _playing;		}		/**		 * @inheritDoc		 */		override public function destruct(deepDestruct:Boolean = false):void		{			super.destruct(deepDestruct);						if(_soundChannelReference) _soundChannelReference.removeEventListener(Event.SOUND_COMPLETE, onSoundComplete);						_sound = null;						_soundChannelReference = null;						_soundTransform = null;						_position = NaN;						_playing = false;						_loopRuns = 0;						loops = 0;		}
		/**		 * @inheritDoc		 */		public function clone():ICloneable		{			var			clone:SoundPlayback = new SoundPlayback(_sound);						clone.loops = loops;						clone.seek(position);						if(playing) clone.play();						return clone;			}		/** @private */		protected function get _soundChannel():SoundChannel		{			return _soundChannelReference;		}		/** @private */		protected function set _soundChannel(value:SoundChannel):void		{			if(_soundChannelReference) _soundChannelReference.removeEventListener(Event.SOUND_COMPLETE, onSoundComplete);						_soundChannelReference = value;						_soundChannelReference.addEventListener(Event.SOUND_COMPLETE, onSoundComplete);		}		private function onSoundComplete(e:Event):void		{			var numLoopsLeft:uint = Math.max(loops - _loopRuns, 0);						if(numLoopsLeft > 0 && playing)			{				playAt(0);								dispatchEvent(new SoundPlaybackEvent(SoundPlaybackEvent.PLAYBACK_LOOP));								_loopRuns = Math.min(_loopRuns + 1, loops);				}			else			{				stop();								dispatchEvent(new SoundPlaybackEvent(SoundPlaybackEvent.PLAYBACK_COMPLETE));				}		}	}}