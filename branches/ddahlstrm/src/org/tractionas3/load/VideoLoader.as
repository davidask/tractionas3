/** * @version 1.0 * @author David Dahlstroem | daviddahlstroem.com *  *  * Copyright (c) 2009 David Dahlstroem | daviddahlstroem.com *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * */ package org.tractionas3.load {	import org.tractionas3.core.interfaces.Cancelable;	import org.tractionas3.debug.LogLevel;	import org.tractionas3.debug.log;	import org.tractionas3.events.Interval;	import org.tractionas3.events.LoaderEvent;	import org.tractionas3.load.CoreLoader;	import org.tractionas3.load.Loadable;	import org.tractionas3.media.VideoMetaData;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.utils.getQualifiedClassName;	/**	 * VideoLoader provides a simple API for loading video files.	 */	public class VideoLoader extends CoreLoader implements Loadable, Cancelable	{		private var _netConnection:NetConnection;		private var _netStream:NetStream;		private var _client:NetStreamClient;		private var _lastBytesLoaded:uint;		private var _metaData:VideoMetaData;				/**		 * Creates a new VideoLoader object.		 * 		 * @param url The URL from wich the data should be loaded.		 * @param loaderName Assigned name to the loader.		 */		public function VideoLoader(url:String = null, loaderName:String = null)		{			super(url, loaderName);						reset();		}		/**		 * Indicates whether the video metadata is available.		 */		public function get hasMetaData():Boolean		{			return (_metaData != null);		}		/**		 * Returns the video meta data if it is available.		 * 		 * @return VideoMetaData instance.		 * @see org.tractionas3.media.VideoMetaData		 */		public function get metaData():VideoMetaData		{			return _metaData;		}		/**		 * @inheritDoc		 */		override public function load(newURL:String = null):void		{			if(newURL) url = newURL;						_netStream.play(getURLRequest().url);						_netStream.pause();						_netStream.seek(0);		}		/**		 * Returns the loader netStream.		 */		public function get netStream():NetStream		{			return data as NetStream;		}		/**		 * Returns the loaded data as a NetStream object.		 * @inheritDoc		 */		override public function get data():*		{			return _netStream;		}		/**		 * @inheritDoc		 */		override public function clone():Object		{			return new VideoLoader(url, name);		}		/**		 * @inheritDoc		 */		override public function reset():void		{						if(_netStream) setEventListeners(false);						_netConnection = new NetConnection();						_netConnection.connect(null);						_netStream = new NetStream(_netConnection);						_client = new NetStreamClient();						_client.onMetaData = handleMetaData;						_client.onXMPData = handleXMPData;						_netStream.client = _client;						_byteReference = new ByteReference(_netStream);						if(_netStream) setEventListeners(true);						_lastBytesLoaded = 0;						_metaData = null;		}		/**		 * @inheritDoc		 */		public function cancel():void		{			var success:Boolean = true;						try			{				_netStream.close();			}			catch(e:Error)			{				success = false;			}						if(success) dispatchLoadCancelEvent();		}		/**		 * @inheritDoc		 */		override public function destruct(deepDestruct:Boolean = false):void		{			cancel();						setEventListeners(false);						_client.destruct(deepDestruct);						super.destruct(deepDestruct);						_netConnection = null;						_netStream = null;						_client = null;						_lastBytesLoaded = 0;						_metaData.destruct(deepDestruct);						_metaData = null;		}		private function setEventListeners(add:Boolean):void		{			var method:String = add ? "addEventListener" : "removeEventListener";						_netStream[method](IOErrorEvent.IO_ERROR, dispatchIOErrorEvent);						_netStream[method](NetStatusEvent.NET_STATUS, handleNetStatusEvent);						if(add)			{				Interval.addIntervalHandler(resolveProgress);			}			else			{				Interval.removeIntervalHandler(resolveProgress);			}		}		private function resolveProgress():void		{			if(bytesLoaded > 0 && bytesLoaded < bytesTotal)			{				dispatchLoadProgressEvent();			}						if(_lastBytesLoaded == 0 && bytesLoaded > 0) dispatchLoadStartEvent();						if(bytesLoaded >= bytesTotal && bytesTotal != 0)			{				Interval.removeIntervalHandler(resolveProgress);								dispatchLoadCompleteEvent();			}						_lastBytesLoaded = bytesLoaded;		}		private function handleNetStatusEvent(e:NetStatusEvent):void		{			switch(e.info["code"] as String)			{				default:					log("Video Status: " + e.info["code"]);					break;			}		}		private function handleMetaData(mData:Object):void		{			_metaData = new VideoMetaData();						for(var property:String in mData)			{				if(!_metaData.hasOwnProperty(property)) log("Property " + property + "(" + getQualifiedClassName(mData[property]) + ") is not defined in VideoMetaData. Adding dynamic property.", LogLevel.TRACTIONAS3);								_metaData[property] = mData[property];			}						dispatchEvent(new LoaderEvent(LoaderEvent.META_DATA));		}		//TODO Add XMP data handler		private function handleXMPData(o:Object):void		{		}	}}import org.tractionas3.core.Destructor;import org.tractionas3.core.interfaces.Destructable;internal class NetStreamClient implements Destructable{	public var onMetaData:Function;	public var onXMPData:Function;		public function destruct(deepDestruct:Boolean = false):void	{		Destructor.destruct(this, deepDestruct);	}	/**	 * @inheritDoc	 */	public function listDestructableProperties():Array	{		return ["onMetaData", "onXMPData"];	}}