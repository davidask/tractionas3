/** * @version 1.0 * @author David Dahlstroem | daviddahlstroem.com *  *  * Copyright (c) 2009 David Dahlstroem | daviddahlstroem.com *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * */package org.tractionas3.profiler {	import org.tractionas3.core.interfaces.IResetable;	import org.tractionas3.events.WeakEventDispatcher;	import flash.utils.getTimer;	/**	 * BandwidthProfiler is used to monitor bandwith activity.	 * Note that BandwidthProfiler only records bandwidth if loading via the TractionAS3 load package.	 */	public class BandwidthProfiler extends WeakEventDispatcher implements IResetable	{		private static var _instance:BandwidthProfiler;		private var _totalBytesLoaded:uint;		private var _totalByteWaste:uint;		private var _initTime:uint;		private var _loadOperationsTotal:uint;		private var _loadOperationsCancelled:uint;		private var _loadOperationsCurrent:uint;		private var _loadOperationsCompleted:uint;		private var _lastBandwidthRecordTime:uint;		private var _lastBandwidthRecordResult:uint;		private var _lastByteRegisterTime:uint;		private var _firstByteRegisterTime:uint;				/**		 * @private		 */		public function BandwidthProfiler(singletonEnforcer:SingletonEnforcer = null)		{			super(this);						if(!singletonEnforcer)			{				throw new ArgumentError("BandwidthProfiler is a singleton class and may only be accessed via its accessor method getInstance()."); 			}						reset();		}		/**		 * BandwidthProfiler accessor.		 */		public static function getInstance():BandwidthProfiler 		{			if(_instance == null) _instance = new BandwidthProfiler(new SingletonEnforcer());			return _instance;		}		/**		 * Returns the total number of bytes loaded via the org.tractionas3.load package.		 */		public function get totalBytesLoaded():uint		{			return getInstance()._totalBytesLoaded;		}		/**		 * Returns the total number of bytes loaded and discarded via the org.tractionas3.load package.		 */		public function get totalByteWaste():uint		{			return getInstance()._totalByteWaste;		}		/**		 * Returns the number of load operations started via the org.tractionas3.load package.		 */		public function get loadOperationsTotal():uint		{			return _loadOperationsTotal;		}		/**		 * Returns the number of load operations currently in progress via the org.tractionas3.load package.		 */		public function get loadOperationsCurrent():uint		{			return _loadOperationsCurrent;		}		/**		 * Returns the number of load operations cancelled via the org.tractionas3.load package.		 */		public function get loadOperationsCancelled():uint		{			return _loadOperationsCancelled;		}		/**		 * Returns the number of load operations completed via the org.tractionas3.load package.		 */		public function get loadOperationsCompleted():uint		{			return _loadOperationsCompleted;		}		/**		 * Returns the current number of bytes loaded per second.		 */		public function get bytesPerSecond():Number		{			var currentTime:uint = getTimer();						var elapsedTime:Number = (currentTime - _lastBandwidthRecordTime) / 1000;						var result:Number = (totalBytesLoaded - _lastBandwidthRecordResult) / elapsedTime;						_lastBandwidthRecordResult = totalBytesLoaded;						_lastBandwidthRecordTime = getTimer();						result = Math.max(result, 0);						return result; 		}		/**		 * Returns the average number of bytes loaded per second during loading.		 */		public function get bytesPerSecondAverage():Number		{			var elapsedTime:Number = (_lastByteRegisterTime - _firstByteRegisterTime) / 1000;						var result:Number = totalBytesLoaded / elapsedTime;						result = (isNaN(result) || result < 0) ? 0 : result;						return result;		}		/**		 * Timestamp for when the bandwidth profiling was initiated.		 */		public function get startTime():uint		{			return _initTime;		}		/**		 * Registers a load operation to BandwidthProfiler		 */		public function registerLoadOperation():void		{			_loadOperationsTotal++;		}		/**		 * Regsters a load operation currently loading to BandwidthProfiler.		 */		public function registerLoadOperationCurrent():void		{			_loadOperationsCurrent++;		}		/**		 * Registers a cancelled load operation to BandwidthProfiler.		 */		public function registerLoadOperationCancelled():void		{			if(_loadOperationsCurrent > 0) _loadOperationsCurrent--;			_loadOperationsCancelled++;		}		/**		 * Registers a completed load operation to BandwidthProfiler.		 */		public function registerLoadOperationCompleted():void		{			if(_loadOperationsCurrent > 0) _loadOperationsCurrent--;			_loadOperationsCompleted++;		}		/**		 * Registers bytes loaded to BandwidthProfiler.		 */		public function registerBytesLoaded(numBytes:uint):void		{			_totalBytesLoaded += numBytes;						_lastByteRegisterTime = getTimer();						if(!_firstByteRegisterTime == 0) _firstByteRegisterTime = getTimer();		}		/**		 * Registers byte waste to BandwidthProfiler.		 */		public function registerByteWaste(numBytes:uint):void		{			_totalByteWaste += numBytes;						_lastByteRegisterTime = getTimer();						if(!_firstByteRegisterTime == 0) _firstByteRegisterTime = getTimer();		}		/**		 * @inheritDoc		 */		public function reset():void		{			_totalBytesLoaded = 0;						_totalByteWaste = 0;						_loadOperationsTotal = 0;					_loadOperationsCancelled = 0;					_loadOperationsCurrent = 0;					_loadOperationsCompleted = 0;						_initTime = getTimer();						_lastBandwidthRecordTime = getTimer();						_lastBandwidthRecordResult = 0;						_firstByteRegisterTime = 0;		}		}}internal class SingletonEnforcer { }