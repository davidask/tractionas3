/** * @version 1.0 * @author David Dahlstroem | daviddahlstroem.com *  *  * Copyright (c) 2009 David Dahlstroem | daviddahlstroem.com *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * */package org.tractionas3.reflection {	import org.tractionas3.data.convertion.PrimitiveTypeConverter;	import flash.utils.describeType;	import flash.utils.getDefinitionByName;	/**	 * DescribeClass provides descriptions of a class.	 */	public class ClassDescriptor 	{		private static var _lastTarget:Object;		private static var _lastDescriptor:XML;				/**		 * Indicates whether specified object is an instance of a dynamic class.		 */		public static function isDynamic(target:Object):Boolean		{			return getDescriptor(target).@isDynamic == "true";		}		/**		 * Returns an array containing interfaces implemented by specified object.		 */		public static function getInterfacesImplemented(target:Object):Array		{			var a:Array = [];						var descriptor:XML = getDescriptor(target);						var implementList:XMLList = descriptor.child("implementsInterface");						for(var i:int = 0;i < implementList.length(); ++i)			{				a.push(getDefinitionByName(XML(implementList[i]).@type));			}						return a;		}		/**		 * Returns an array containing method descriptors for the mehods of specified object. 		 */		public static function getMethods(target:Object):Array		{			var a:Array = [];						if(!target) return [];						var descriptor:XML = getDescriptor(target);						var methodList:XMLList = descriptor.child("method");						var methodDescriptor:MethodDescriptor;						var methodDescription:XML;						var methodParameters:XMLList;						var parameterDescriptor:ParameterDescriptor;						var parameterDescription:XML;						for(var i:int = 0;i < methodList.length(); ++i)			{				methodDescription = methodList[i] as XML;								methodDescriptor = new MethodDescriptor();								methodDescriptor.name = methodDescription.@name;								methodDescriptor.declaredBy = getDefinitionByName(methodDescription.@declaredBy) as Class;								try				{					methodDescriptor.returnType = getDefinitionByName(methodDescription.@returnType) as Class;										methodDescriptor.returnTypeName = trimQualifiedClassName(methodDescription.@returnType);				}				catch(e:Error)				{					/* Returns void or "*" */				}								methodDescriptor.parameters = [];								methodParameters = methodDescription.child("parameter");								for(var ii:int = 0;ii < methodParameters.length(); ++ii)				{					parameterDescription = methodParameters[ii] as XML;						parameterDescriptor = new ParameterDescriptor();										parameterDescriptor.index = parseInt(parameterDescription.@index);										try					{						parameterDescriptor.type = getDefinitionByName(parameterDescription.@type) as Class;												parameterDescriptor.typeName = trimQualifiedClassName(parameterDescription.@type);					}					catch(e:Error)					{						/* Returns void or "*" */					}										parameterDescriptor.optional = PrimitiveTypeConverter.toBoolean(parameterDescription.@optional);										methodDescriptor.parameters.push(parameterDescriptor);				}								a.push(methodDescriptor);			}						return a;		}		/**		 * Returns an array containing property descriptors for the properties of specified object.		 */		public static function getProperties(target:Object):Array		{			var a:Array = [];						if(!target) return [];						var descriptor:XML = getDescriptor(target);						var propertyList:XMLList = descriptor.child("variable");						var propertyDescription:XML;						var propertyDescriptor:PropertyDescriptor;						var accessorList:XMLList = descriptor.child("accessor");						var accessorDescription:XML;						for(var i:int = 0;i < propertyList.length(); ++i)			{				propertyDescription = propertyList[i] as XML;								propertyDescriptor = new PropertyDescriptor();								propertyDescriptor.access = PropertyDescriptor.READ_WRITE;								propertyDescriptor.name = propertyDescription.@name;								try				{					propertyDescriptor.type = getDefinitionByName(propertyDescription.@type) as Class;										propertyDescriptor.typeName = trimQualifiedClassName(propertyDescription.@type);				}				catch(e:Error)				{					/* Returns void or "*" */				}												a.push(propertyDescriptor);			}						for(var ii:int = 0;ii < accessorList.length(); ++ii)			{				accessorDescription = accessorList[ii] as XML;								propertyDescriptor = new PropertyDescriptor();								propertyDescriptor.access = accessorDescription.@access;								propertyDescriptor.name = accessorDescription.@name;								try				{					propertyDescriptor.type = getDefinitionByName(accessorDescription.@type) as Class;										propertyDescriptor.typeName = trimQualifiedClassName(accessorDescription.@type);				}				catch(e:Error)				{					/* Returns void or "*" */				}								a.push(propertyDescriptor);			}						a.sortOn("name");						return a;		}		/**		 * Returns an array containing <i>readable</i> property descriptors for the properties of specified object.		 */		public static function getReadableProperties(target:Object):Array		{			var properties:Array = getProperties(target);						var propertyDescriptor:PropertyDescriptor;						var a:Array = [];						for(var i:int = 0;i < properties.length; ++i)			{				propertyDescriptor = properties[i] as PropertyDescriptor;								if(propertyDescriptor.readable) a.push(propertyDescriptor);			}						return a;		}		/**		 * Returns an array containing the inheritance of specified object.		 */		public static function getInheritance(target:Object):Array		{			var a:Array = [];						var descriptor:XML = getDescriptor(target);						var inheritanceDescription:XML;						var inheritanceList:XMLList = descriptor.child("extendsClass");						for(var i:int = 0;i < inheritanceList.length(); ++i)			{				inheritanceDescription = inheritanceList[i] as XML;								a.push(getDefinitionByName(inheritanceDescription.@type) as Class);			}						return a;		}		private static function getDescriptor(target:Object):XML		{			if(_lastTarget == target)			{				return _lastDescriptor;			}						_lastTarget = target;						_lastDescriptor = describeType(target);						return _lastDescriptor;		}	}}