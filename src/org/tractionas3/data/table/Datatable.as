/** * @version 1.0 * @author David Dahlstroem | daviddahlstroem.com *  *  * Copyright (c) 2009 David Dahlstroem | daviddahlstroem.com *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * */package org.tractionas3.data.table {	import org.tractionas3.core.CoreObject;	import org.tractionas3.core.Destructor;	import org.tractionas3.data.table.DatatableColumn;	import org.tractionas3.data.table.DatatableField;	import org.tractionas3.data.table.DatatableRow;	import org.tractionas3.data.table.IDatatable;	import org.tractionas3.reflection.stringify;	import flash.errors.EOFError;	/**	 * DataTable class allows you to store data in an abstract table.	 * 	 * Using a data table is a lot easier than using a multi dimentional array, and allthough being slower to process	 * it is consuming much less memory. The DataTable class is strictly typed and will only accept values of the type	 * specified in each field.	 * <p>	 * DataTable implements methods and properties resembling a RecordSet such as <code>moveNext()</code> and <code>EOF</code>	 * </p>	 * <p>	 * The best way to use a DataTable is to extend it and to define its fields in the constructor, also storing the field names and the data table name	 * in static constants. 	 * </p>	 * 	 */	public class Datatable extends CoreObject implements IDatatable	{		private var _name:String;		private var _columns:Array;		private var _fields:Array;		private var _primary:DatatableField;		private var _numRows:uint;		private var _cursor:uint;		/**		 * Creates a new Datatable object.		 */		public function Datatable(name:String)		{			super();						_name = name;						reset();		}		/**		 * @inheritDoc 		 */		final public function addField(name:String, dataType:Class, primary:Boolean = false):DatatableField		{				var field:DatatableField = new DatatableField(name, dataType);						if(primary) _primary = field; 						var column:DatatableColumn = new DatatableColumn(field);						_fields.push(field);						_columns.push(column);						return field;		}		/**		 * @inheritDoc 		 */		final public function removeField(name:String):void		{						var field:DatatableField;						var removedField:DatatableField;						var removedColumn:DatatableColumn;						for(var i:int = 0;i < _fields.length; ++i)			{				field = _fields[i] as DatatableField;								if(field.name == name)				{					removedColumn = _columns[i];					removedColumn.destruct();										removedField = field;					removedField.destruct();										_fields.splice(i, 1);										_columns.splice(i, 1);					return;				}			}		}		/**		 * @inheritDoc 		 */		final public function getFieldNames():Array		{			var a:Array = [];						for(var i:int = 0;i < fieldCount; ++i)			{				a.push((DatatableField(_fields[i]).name));			}						return a;		}		/**		 * @inheritDoc 		 */		final public function getFieldDataTypes():Array		{			var a:Array = [];						for(var i:int = 0;i < fieldCount; ++i)			{				a.push((DatatableField(_fields[i]).dataType));			}						return a;		}		/**		 * @inheritDoc 		 */		final public function get cursor():uint		{			return _cursor;		}		/**		 * @inheritDoc 		 */		final public function get EOF():Boolean		{			return (cursor == rowCount);		}		/**		 * @inheritDoc 		 */		final public function get BOF():Boolean		{			return (cursor == 0);		}		/**		 * @inheritDoc 		 */		final public function moveNext():void		{			_cursor++;						if(cursor >= rowCount)			{				throw new EOFError("Cursor index exceeds rowCount.");			}		}		/**		 * @inheritDoc 		 */		final public function movePrevious():void		{			if(cursor == 0) return;						_cursor--;		}		/**		 * @inheritDoc 		 */		final public function moveFist():void		{			_cursor = 0;		}		/**		 * @inheritDoc 		 */		final public function moveLast():void		{			_cursor = rowCount - 1;		}		/**		 * @inheritDoc 		 */		final public function getFieldIndexByName(name:String):int		{						var field:DatatableField;						for(var i:int = 0;i < fieldCount; ++i)			{				field = _fields[i] as DatatableField;								if(field.name === name) return i;			}						throw new Error("Field " + name + " not found.");						return -1;		}		/**		 * @inheritDoc 		 */		final public function get hasPrimary():Boolean		{			return (_primary != null);		}		/**		 * @inheritDoc 		 */		final public function get fieldCount():uint		{			if(!_fields) return 0;						return _fields.length;		}		/**		 * @inheritDoc 		 */		final public function get rowCount():uint		{			return _numRows;		}		/**		 * @inheritDoc 		 */		final public function get name():String		{			return _name;		}		/**		 * @inheritDoc 		 */		final public function addRow(...args:Array):void		{			if(args.length != fieldCount)			{				throw new ArgumentError("Wrong number of row values. Expected " + fieldCount + " values, got " + args.length + ".");								return;			}						var value:*;						var column:DatatableColumn;						for(var i:int = 0;i < fieldCount; ++i)			{				value = args[i];								column = _columns[i] as DatatableColumn;								column.addValue(value);			}			_numRows++;		}		/**		 * @inheritDoc		 */		final public function removeRowAt(index:uint):void		{				for(var i:int = 0;i < fieldCount; ++i)			{				DatatableColumn(_columns[i]).removeValueAt(index);			}						_numRows--;		}		/**		 * @inheritDoc 		 */		final public function removeRowsByMatch(fieldIdentifier:*, match:*):int		{			var n:int = 0;						var value:*;						var columnIndex:uint = interpretFieldIdeintifier(fieldIdentifier);						for(var i:int = 0;i < rowCount; ++i)			{				value = getValue(columnIndex, i);								if(value === match)				{					removeRowAt(i);					i--;					n++;				}			}						return n;		}		/**		 * @inheritDoc 		 */		final public function getRowAt(index:uint):DatatableRow		{			if(index > rowCount - 1) return null;						return new DatatableRow(this, index);			}		/**		 * @inheritDoc		 */		final public function getRowsByMatch(fieldIdentifier:*, match:*):Array		{			var a:Array = [];						var value:*;						var columnIndex:uint = interpretFieldIdeintifier(fieldIdentifier);						for(var i:int = 0;i < rowCount; ++i)			{				value = getValue(columnIndex, i);								if(value === match)				{					a.push(new DatatableRow(this, i));				}			}						return a;		}		/**		 * @inheritDoc 		 */		final public function getRow():DatatableRow		{			return getRowAt(cursor);		}		/**		 * @inheritDoc 		 */		final public function getValue(fieldIdentifier:*, rowIndex:uint):*		{							var fieldIndex:uint = interpretFieldIdeintifier(fieldIdentifier);						if(rowIndex > rowCount - 1 || fieldIndex > fieldCount - 1) return null;						return DatatableColumn(_columns[fieldIndex]).getValueAt(rowIndex);		}		/**		 * @inheritDoc 		 */		final public function hasValue(value:*, fieldIdentifier:*):Boolean		{			var column:DatatableColumn = _columns[interpretFieldIdeintifier(fieldIdentifier)] as DatatableColumn;						if(column.values.indexOf(value) > -1) return true;						return false;			}		/**		 * @inheritDoc 		 */		override public function toString():String		{						var			output:String = "-------------------------------------------------------------------\n";			output += stringify(this) + "\n";			output += "-------------------------------------------------------------------\n";						for(var i:int = 0;i < fieldCount; ++i)			{				output += DatatableField(_fields[i]).name;				if(i < fieldCount - 1) output += ", ";			}						output += "\n\n";						for(var ii:int = 0;ii < rowCount; ++ii)			{				output += getRowAt(ii).values + "\n";			}			output += "-------------------------------------------------------------------\n";						return output;		}		/**		 * @inheritDoc 		 */		public function reset():void		{			if(_columns) Destructor.destructMultiple(_columns);						if(_fields) Destructor.destructMultiple(_fields);						_columns = [];						_fields = [];						_numRows = 0;		}		/**		 * @inheritDoc		 */		override public function destruct(deepDestruct:Boolean = false):void		{			reset();						_name = null;						_columns = null;						_fields = null;						_primary = null;						_numRows = 0;						_cursor = 0;						super.destruct(deepDestruct);		}		private function interpretFieldIdeintifier(identifier:*):uint		{			var fieldIndex:uint;						switch(true)			{				case (identifier is String):					fieldIndex = getFieldIndexByName(identifier);					break;								case (identifier is uint):					fieldIndex = identifier;					break;								default:										throw new Error("Wrong field identifier. Name not found or index out of range.");										return null;					break;			}					return fieldIndex;		}	}}