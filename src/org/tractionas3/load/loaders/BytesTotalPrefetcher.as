/** * @version 1.0 * @author David Dahlstroem | daviddahlstroem.com *  *  * Copyright (c) 2009 David Dahlstroem | daviddahlstroem.com *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. * */package org.tractionas3.load.loaders{	import org.tractionas3.core.Destructor;	import org.tractionas3.core.interfaces.ICancelable;	import org.tractionas3.core.interfaces.ICoreInterface;	import org.tractionas3.events.LoaderEvent;	import org.tractionas3.events.WeakEventDispatcher;	import org.tractionas3.profiler.BandwidthProfiler;	import flash.events.ProgressEvent;	import flash.net.URLLoader;	import flash.net.URLRequest;	/**	 * BytesTotalPrefetcher is a class used to determine a files size before loading it.	 * 	 * <p>	 * Prefetching file size involves a second load process, which is immeadiately cancelled as soon as the file	 * size is detected. Any loaded data (and reference to it) is discarded. The amount of time a prefetch takes is not determined by the connection speed, but rather	 * the latency.	 * </p>	 * 	 * @see #byteWaste	 */	public class BytesTotalPrefetcher extends WeakEventDispatcher implements ICoreInterface, ICancelable	{		private var _urlLoader:URLLoader;		private var _byteWaste:uint;		private var _bytesTotal:uint;		private var _prefetchComplete:Boolean = false;				/**		 * BytesTotalPrefetcher Constructor		 * 		 * @param request URLRequest defining the URL of the file to load.		 */		public function BytesTotalPrefetcher(request:URLRequest)		{			super();						_urlLoader = new URLLoader(request);						_urlLoader.addEventListener(ProgressEvent.PROGRESS, prefetch);		}		/**		 * @inheritDoc 		 */		override public function destruct(deepDestruct:Boolean = false):void		{				cancel();						_urlLoader = null;						_byteWaste = 0;						_bytesTotal = 0;						_prefetchComplete = false;						Destructor.destruct(this, deepDestruct);		}		/**		 * Cancels the prefetch.		 */		public function cancel():void		{			if(!_urlLoader) return;			_urlLoader.removeEventListener(ProgressEvent.PROGRESS, prefetch);						try 			{						_urlLoader.close();			}			catch(e:Error) 			{			}		}		/**		 * Returns the prefetched file size of target file. 		 * 		 * @return File size in bytes.		 */		public function getPrefetchedBytesTotal():uint		{			return _bytesTotal;		}		/**		 * Returns the number of excess loaded bytes caused by the prefetch.		 * <p>		 * Note that the file size is fetched as soon as any load progress is detected, no matter how small.		 * This means that the amount of excess loaded bytes is in direct proportion to the connection speed		 * between client and server. A slower connection will load less excess amount of data than a fast connection.		 * </p>		 * @return Excess loaded amount of data in bytes.		 */		public function getByteWaste():uint		{			return _byteWaste;		}		/**		 * Indicates whether the prefetch is complete.		 */		public function get prefetchComplete():Boolean		{			return _prefetchComplete;		}		private function prefetch(e:ProgressEvent):void		{			_urlLoader.removeEventListener(ProgressEvent.PROGRESS, prefetch);						_byteWaste = _urlLoader.bytesLoaded;						_bytesTotal = _urlLoader.bytesTotal;						BandwidthProfiler.getInstance().registerByteWaste(getByteWaste());							BandwidthProfiler.getInstance().registerBytesLoaded(getByteWaste());						_prefetchComplete = true;						this.dispatchEvent(new LoaderEvent(LoaderEvent.BYTESTOTAL_PREFETCHED));						_urlLoader.close();						_urlLoader = null;		}	}}